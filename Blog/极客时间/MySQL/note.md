

# MySQL



## 基本逻辑架构

<img src="https://i.loli.net/2021/04/06/Fcj9DBqzS6Cw25x.png" alt="MySQL的逻辑架构图" style="zoom: 33%;" />

在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因



## 日志模块

日志模块是用来保护MySQL数据库的可靠性的。MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。

### redo log（重做日志）

当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。与Redis的AOF持久化机制不同，MySQL是在执行之前写入日志，Redis是在执行之后写入日志。

同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。

<img src="https://i.loli.net/2021/04/06/5gBVUywIuLAxcis.png" alt="image-20210406211839298" style="zoom:50%;" />

有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为**crash-safe**。redo log 是 InnoDB 引擎特有的日志

### binlog（归档日志）

binlog（归档日志）是 Server 层的日志，因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。



这两种日志有以下三点不同。

1. redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。
2. redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。
3. redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

<img src="https://i.loli.net/2021/04/21/d3a72jEDtvyb6rp.png" alt="img" style="zoom:33%;" />

最后三步看上去有点“绕”，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是"两阶段提交"。

由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。





## 事务隔离

> ACID（原子性、隔离性、持久性、一致性）

### 隔离问题

1. 脏读
2. 不可重复读
3. 幻读



### 隔离机制

- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- 串行化，顾名思义是对于同一行记录，**“写”会加“写锁”，“读”会加“读锁”**。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。



在具体的实现上，数据库里面会创建一个视图。对于读提交来说，事务中的每一次操作都会生成一个新的视图，如果这期间某个事务提交了，那么他就会从视图中移除，这样确保事务每一次的读操作都能读取到最新的数据。对于可重复读来说，事务只有在第一次进行读操作的时候才会生成一个视图，后续的读操作都会重复使用这个视图，也就是说，如果在此期间有其他事务提交了，那么对于可重复读来说也是不可见的。而读未提交不存在视图这个概念，每一次从数据库中读取的数据都是最新的。



MVC可重复读的实现是：

在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。

![MVCC版本链](https://i.loli.net/2021/04/06/KfILPmpQ6tDxWyA.png)





---

- [MVCC如何实现数据库读已提交和可重复读这两种隔离级别？_SCUTJAY的博客-CSDN博客_读已提交是怎么实现的](https://blog.csdn.net/SCUTJAY/article/details/104653599)



## 索引

一句话简单来说，**索引的出现其实就是为了提高数据查询的效率**，就像书的目录一样。













## 查询实践



1. 取交集
2. 取并集
3. 取差集
4. 多表查询





