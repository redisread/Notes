



字节一面：

- 汉诺塔复杂度：$O(2^n)$

  T（n）=2T（n-1)+1

- 虚拟内存

  隔离每一个进程的数据。

  让分配更加简单。

  内存仿佛无限大。

- 中断过程

  先保存当前指令，然后去查询中断向量表执行中断程序，执行完中断程序之后再回来执行原来的指令。

- top返回的信息

  - pid gid
  - PR — 进程优先级
  - NI — nice值。负值表示高优先级，正值表示低优先级
  - VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES
  - RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA
  - SHR — 共享内存大小，单位kb
  - 用户
  - 运行时间
  - CPU占用率和内存占用率
  - 进程状态
  - 进程的执行命令

- 文件系统

  Inode节点、FCBlink中的数据

  Inode：

  文件的字节数
  文件的所有者ID
  文件的所在组ID
  文件的读写执行权限
  文件的时间戳就是我们stat显示出来下边的最大的一块。Inode上次变动的时间，文件上次变动的时间，文件上次打开的时间。
  文件的链接数
  文件数据block的位置信息

- 软连接和硬链接

  ![Linux硬链接和软连接的区别](https://xzchsia.github.io/img/in-post/linux-hard-soft-link/linux-soft-hard-link-diff.png)

  硬链接：

  - 1. 具有相同inode节点号的多个文件互为硬链接文件；
  - 1. 删除硬链接文件或者删除源文件任意之一，文件实体并未被删除；
  - 1. 只有删除了源文件和所有对应的硬链接文件，文件实体才会被删除；
  - 1. 硬链接文件是文件的另一个入口；
  - 1. 可以通过给文件设置硬链接文件来防止重要文件被误删；
  - 1. 创建硬链接命令 ln 源文件 硬链接文件；
  - 1. 硬链接文件是普通文件，可以用rm删除；
  - 1. 对于静态文件（没有进程正在调用），当硬链接数为0时文件就被删除。注意：如果有进程正在调用，则无法删除或者即使文件名被删除但空间不会释放。

  软连接：

  - 1. 软链接类似windows系统的快捷方式；
  - 1. 软链接里面存放的是源文件的路径，指向源文件；
  - 1. 删除源文件，软链接依然存在，但无法访问源文件内容；
  - 1. 软链接失效时一般是白字红底闪烁；
  - 1. 创建软链接命令 ln -s 源文件 软链接文件；
  - 1. 软链接和源文件是不同的文件，文件类型也不同，inode号也不同；
  - 1. 软链接的文件类型是“l”，可以用rm删除。

  区别：

  原理上，硬链接和源文件的inode节点号相同，两者互为硬链接。软连接和源文件的inode节点号不同，进而指向的block也不同，软连接block中存放了源文件的路径名。 实际上，硬链接和源文件是同一份文件，而软连接是独立的文件，类似于快捷方式，存储着源文件的位置信息便于指向。 使用限制上，不能对目录创建硬链接，不能对不同文件系统创建硬链接，不能对不存在的文件创建硬链接；可以对目录创建软连接，可以跨文件系统创建软连接，可以对不存在的文件创建软连接。

  [Linux硬链接和软连接的区别与总结 - Hsia的博客 | Hsia Blog](https://xzchsia.github.io/2020/03/05/linux-hard-soft-link/)



Linux常见文件系统中或者命令操作返回的数据

[Linux讲解 文件系统 inode节点_Hanani_Jia的博客-CSDN博客](https://blog.csdn.net/Hanani_Jia/article/details/82776984)

[汉诺塔问题以及时间复杂度_No Code No Life-CSDN博客_汉诺塔时间复杂度](https://blog.csdn.net/qq_33274645/article/details/52688025)





### 迭代器失效

删除 或者重新分配内存





CAS



访问页表的次数TLB



数据结构



计算机网络：



- 组合和继承的区别？

  继承是紧耦合，组合是松耦合的。

- 多线程问题，智能指针与红黑树与迭代器的多线程问题

  为什么智能指针要加锁

  共享智能指针里面的成员变量其实是有两个的，分别是变量指针和计数器指针，当多线程并发读的时候没有问题，但是多线程并发写的时候会有问题。原因是操作量指针和计数器指针不是原子操作，在操作它们两个变量的时候，可能在中间插入了未知的操作。就像

  ```cpp
  this->p = p;
  // 这里另外一个线程执行了一些语句，例如释放了p
  this->count++;
  ```

  ```cpp
  this->count++;
// 这里另外一个线程执行了一些语句，例如count++,在这里计数就不正确了
  this->p = p;
  ```

  如果析构视为写操作，那么两个线程同时写（析构）也会有竞争吧？ 假如shared_ptr的析构代码如下： `refcount--; if (refcount ==0) delete ptr;` 如果两个线程同时执行完refcount--，使得refcount==0; 那么**会调用两次delete ptr而导致异常**？除非refcount--和if语句是原子操作。‘
  
  ```cpp
  refcount--;
  if (refcount ==0) delete ptr;
  ```
  
  为什么红黑树的操作要加锁
  
  红黑树也是一样的，并发读没有什么问题，但是并发写就会有问题。因为红黑树里面也不是一个变量这么简单，里面包含的我们需要保存的变量和红黑树的颜色。如果对这两个变量的操作不是一个原子操作的话，那么就会引发未知行为。
  
  **因为 HashMap 对 put 操作没有进行加锁的操作，那么就不能保证下一个线程 get 到的值，就一定是没有被修改过的值，所以 HashMap 是不安全的**



网络模型：

**同步模型（synchronous IO）**

阻塞IO（bloking IO）

非阻塞IO（non-blocking IO）

多路复用IO（multiplexing IO）

信号驱动式IO（signal-driven IO）

**异步IO（asynchronous IO）**



同步阻塞

同步非阻塞

多路复用

异步

[聊聊Linux 五种IO模型 - 简书](https://www.jianshu.com/p/486b0965c296)



redis数据库

隔离机制？

读未提交、读提交、可重复读、串行化

事务

ACID：隔离性、持久性、一致性、原子性

redis为什么这么快





从节点如何和主节点进行通信

主从同步

RDB



用户态和内核态(为什么要区分)：

- 有一些指令是很危险的，如果错用，将导致整个系统崩溃。
- 内核运行更快？





算法题目：

Z字形遍历二叉树



### 数据库





### 股票问题



- 121 一次
- 122 无数次
- 123 3次
- 309 cod down 放了技能不能再放
- **188 k次**
- 714 交易手续费



使用一个动态规划的思路进行解决

主要解决k次交易的问题

- 状态定义 到i天的最大利润
- 



HTTPS

路由

红黑树

RSA

数字签名和加密



信息论 测试

小白鼠实验

哈希重哈希



<embed height="100" width="100" src="./00-开篇词丨想成为技术牛人？先搞定网络协议！.mp3">



